<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Test del Ala - Checklist de Mejoras</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, #87CEEB, #FFFFFF);
            overflow: hidden;
        }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 10px;
            max-width: 250px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #checklist {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 10px;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            #controls {
                max-width: 200px;
                padding: 12px;
            }
            #checklist {
                max-width: 300px;
                right: 5px;
                padding: 12px;
            }
        }

        @media (max-width: 900px) {
            #controls {
                position: absolute;
                top: auto;
                bottom: 10px;
                left: 10px;
                max-width: calc(100vw - 20px);
                padding: 15px;
                border-radius: 12px;
            }
            #checklist {
                position: absolute;
                top: 10px;
                right: 10px;
                left: 10px;
                max-width: calc(100vw - 20px);
                max-height: 35vh;
                padding: 15px;
                border-radius: 12px;
            }
            #controls input[type="range"] {
                width: 100%;
                height: 8px;
                margin: 10px 0;
            }
            #controls button {
                width: 100%;
                padding: 12px;
                margin: 5px 0;
                font-size: 16px;
                min-height: 44px;
            }
        }

        /* Mobile specific optimizations */
        @media (max-width: 768px) {
            #mobile-menu-toggle {
                display: block;
            }

            #controls {
                position: fixed;
                bottom: 10px;
                left: 70px;
                right: 10px;
                max-width: none;
                padding: 12px;
                border-radius: 12px;
                font-size: 14px;
                z-index: 1000;
            }

            #checklist {
                position: fixed;
                top: 0;
                left: -100%;
                width: 80%;
                max-width: 300px;
                height: 100vh;
                border-radius: 0;
                padding: 20px;
                font-size: 13px;
                transition: left 0.3s ease;
                z-index: 1000;
                overflow-y: auto;
            }

            #checklist.open {
                left: 0;
            }

            #controls input[type="range"] {
                width: 100%;
                height: 8px;
                margin: 10px 0;
            }

            #controls button {
                width: 48%;
                padding: 12px;
                margin: 2px;
                font-size: 14px;
                min-height: 44px;
            }

            #controls label {
                display: block;
                margin: 8px 0;
                font-size: 14px;
            }

            #controls input[type="checkbox"] {
                width: 20px;
                height: 20px;
                margin-right: 8px;
            }

            .check-item {
                padding: 8px;
                margin: 6px 0;
                font-size: 12px;
            }
        }

        /* Small mobile devices */
        @media (max-width: 480px) {
            #controls {
                padding: 10px;
                font-size: 13px;
            }
            #checklist {
                padding: 10px;
                max-height: 25vh;
                font-size: 12px;
            }
            #controls button {
                padding: 10px;
                font-size: 14px;
            }
            .check-item {
                padding: 6px;
                font-size: 11px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            #controls input[type="range"] {
                height: 12px;
                -webkit-appearance: none;
                appearance: none;
                background: #ddd;
                border-radius: 6px;
            }
            #controls input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 24px;
                height: 24px;
                border-radius: 50%;
                background: #2196F3;
                cursor: pointer;
            }
            #controls button {
                -webkit-tap-highlight-color: rgba(33, 150, 243, 0.3);
            }
            #checklist {
                -webkit-overflow-scrolling: touch;
            }
        }

        /* Prevent text selection on touch */
        @media (hover: none) {
            * {
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none;
            }
            input, button, textarea, select {
                -webkit-user-select: text;
                -moz-user-select: text;
                -ms-user-select: text;
                user-select: text;
            }
        }

        #mobile-menu-toggle {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1001;
        }

        #mobile-menu-toggle button {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }

        #mobile-menu-toggle button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(33, 150, 243, 0.4);
        }

        #mobile-menu-toggle button:active {
            transform: scale(0.95);
        }

        #breadcrumb {
            display: none;
            position: fixed;
            top: 10px;
            left: 80px;
            right: 80px;
            background: rgba(255,255,255,0.95);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        #breadcrumb span {
            color: #666;
        }

        #breadcrumb strong {
            color: #2196F3;
        }

        #back-button {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
        }

        #back-button button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            border: none;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(33, 150, 243, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        #back-button button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        #back-button button:active {
            transform: scale(0.95);
        }

        #checklist-header {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
        }

        #checklist-header h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }

        #search-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        #checklist-search {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        #checklist-search:focus {
            outline: none;
            border-color: #2196F3;
            box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
        }

        #clear-search {
            width: 30px;
            height: 30px;
            border: none;
            background: #f0f0f0;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #666;
        }

        #clear-search:hover {
            background: #e0e0e0;
        }

        #close-menu-btn {
            align-self: flex-end;
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
            padding: 5px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #quick-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        #quick-actions button {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        #quick-actions button:hover {
            background: #f5f5f5;
            border-color: #2196F3;
        }

        #quick-actions button:active {
            transform: scale(0.95);
        }
        .check-item { margin: 8px 0; padding: 5px; border-radius: 5px; }
        .check-item.completed { background: #e8f5e8; border-left: 4px solid #4CAF50; }
        .check-item.pending { background: #fff3cd; border-left: 4px solid #ffc107; }
        .check-item.improvement { background: #e3f2fd; border-left: 4px solid #2196F3; }

        /* Collapsible checklist styles */
        .checklist-category {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }

        .category-header {
            background: #f5f5f5;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .category-header:hover {
            background: #e8f4fd;
        }

        .category-header h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .toggle-icon {
            font-size: 12px;
            color: #666;
            transition: transform 0.2s ease;
        }

        .category-content {
            padding: 0;
        }

        .category-content .check-item {
            border-bottom: 1px solid #f0f0f0;
            margin: 0;
            border-radius: 0;
        }

        .category-content .check-item:last-child {
            border-bottom: none;
        }
        .status { font-weight: bold; font-size: 12px; }
        .completed { color: #4CAF50; }
        .pending { color: #ff9800; }
        .improvement { color: #2196F3; }
    </style>
</head>
<body>
    <div id="mobile-menu-toggle">
        <button id="menu-btn" onclick="toggleMobileMenu()">‚ò∞</button>
    </div>

    <div id="breadcrumb">
        <span>Simulador</span> > <strong>Checklist de Mejoras</strong>
    </div>

    <div id="back-button">
        <button onclick="goBack()">‚Üê</button>
    </div>

    <div id="mobile-overlay" onclick="closeMobileMenu()"></div>

    <div id="controls">
        <h3>Controles de Test</h3>
        <label>√Ångulo de Ataque: <span id="angle-value">5</span>¬∞</label><br>
        <input type="range" id="angle-slider" min="0" max="25" value="5" step="1"><br><br>
        <label>Mostrar Detalles:</label><br>
        <input type="checkbox" id="show-details" checked> Etiquetas<br>
        <input type="checkbox" id="show-pressure" checked> Presiones<br>
        <input type="checkbox" id="show-flows" checked> Flujos<br>
        <input type="checkbox" id="show-forces" checked> Fuerzas<br><br>
        <div id="quick-actions">
            <button onclick="quickPreset('all')">Mostrar Todo</button>
            <button onclick="quickPreset('minimal')">M√≠nimo</button>
            <button onclick="quickPreset('physics')">Solo F√≠sica</button>
        </div>
    </div>

    <div id="checklist">
        <div id="checklist-header">
            <h3>Checklist de Mejoras del Ala</h3>
            <div id="search-container">
                <input type="text" id="checklist-search" placeholder="Buscar..." oninput="filterChecklist(this.value)">
                <button id="clear-search" onclick="clearSearch()" style="display: none;">‚úï</button>
            </div>
            <button id="close-menu-btn" onclick="closeMobileMenu()">‚úï</button>
        </div>
        <div id="checklist-items"></div>
    </div>

    <script>
        let angleSlider, showDetails, showPressure, showFlows, showForces;
        let angleAttack = radians(5);
        let flowOffset = 0;

        // Checklist data
        const checklistItems = [
            // Vista del Ala
            { category: "Vista del Ala", item: "Perfil NACA 2412 preciso", status: "completed", description: "Curvas de Bezier implementadas correctamente" },
            { category: "Vista del Ala", item: "Grosor del perfil realista", status: "completed", description: "Borde interior y borde de ataque reforzado" },
            { category: "Vista del Ala", item: "Textura met√°lica", status: "completed", description: "Gradientes met√°licos y brillos especulares implementados" },
            { category: "Vista del Ala", item: "Sombras 3D", status: "completed", description: "Sombras volum√©tricas con direcci√≥n de luz" },
            { category: "Vista del Ala", item: "Detalles de superficie", status: "completed", description: "Paneles, remaches y antenas GPS agregados" },
            { category: "Vista del Ala", item: "Efectos de desgaste", status: "completed", description: "Manchas de uso e hielo en condiciones espec√≠ficas" },

            // Flujos de Aire
            { category: "Flujos de Aire", item: "L√≠neas de corriente superiores", status: "completed", description: "Flujos azules siguiendo contorno superior" },
            { category: "Flujos de Aire", item: "L√≠neas de corriente inferiores", status: "completed", description: "Flujos naranjas siguiendo contorno inferior" },
            { category: "Flujos de Aire", item: "Part√≠culas animadas", status: "completed", description: "Puntos siguiendo las l√≠neas de flujo" },
            { category: "Flujos de Aire", item: "Velocidad variable por √°ngulo", status: "completed", description: "Flujos m√°s r√°pidos en √°ngulos altos" },
            { category: "Flujos de Aire", item: "Efectos de turbulencia", status: "pending", description: "Ondulaciones y remolinos en stall" },
            { category: "Flujos de Aire", item: "Separaci√≥n del flujo", status: "completed", description: "Efectos cuando Œ± > 12¬∞" },
            { category: "Flujos de Aire", item: "Boundary layer visualization", status: "improvement", description: "Capa l√≠mite visible cerca de la superficie" },

            // Presiones
            { category: "Presiones", item: "Gradiente de presi√≥n superior", status: "completed", description: "Azul para baja presi√≥n" },
            { category: "Presiones", item: "Gradiente de presi√≥n inferior", status: "completed", description: "Rojo para alta presi√≥n" },
            { category: "Presiones", item: "L√≠neas de contorno", status: "completed", description: "Isobaras curvas" },
            { category: "Presiones", item: "Animaci√≥n de contornos", status: "pending", description: "Contornos ondulantes con el tiempo" },
            { category: "Presiones", item: "Valores num√©ricos", status: "improvement", description: "Mostrar valores de presi√≥n en Pa" },
            { category: "Presiones", item: "Efectos de compresibilidad", status: "improvement", description: "Cambios en altas velocidades" },

            // Fuerzas
            { category: "Fuerzas", item: "Flecha de sustentaci√≥n", status: "completed", description: "Verde desde borde de ataque" },
            { category: "Fuerzas", item: "Flecha de peso", status: "completed", description: "Roja hacia abajo" },
            { category: "Fuerzas", item: "Fuerza de arrastre", status: "pending", description: "Flecha horizontal de resistencia" },
            { category: "Fuerzas", item: "Momento de cabeceo", status: "improvement", description: "Torque alrededor del centro aerodin√°mico" },
            { category: "Fuerzas", item: "Centro de presi√≥n", status: "improvement", description: "Punto donde act√∫a la fuerza resultante" },

            // Interactividad
            { category: "Interactividad", item: "Control de √°ngulo de ataque", status: "completed", description: "Slider funcional 0-25¬∞" },
            { category: "Interactividad", item: "Animaci√≥n autom√°tica", status: "pending", description: "Modo demo con √°ngulos variables" },
            { category: "Interactividad", item: "Zoom y pan", status: "improvement", description: "Acercamiento a detalles espec√≠ficos" },
            { category: "Interactividad", item: "Modo comparaci√≥n", status: "improvement", description: "Comparar diferentes perfiles NACA" },
            { category: "Interactividad", item: "Captura de pantalla", status: "pending", description: "Guardar im√°genes del estado actual" },

            // F√≠sica
            { category: "F√≠sica", item: "Principio de Bernoulli", status: "completed", description: "Velocidad ‚Üî Presi√≥n correctamente mostrado" },
            { category: "F√≠sica", item: "Coeficiente de sustentaci√≥n", status: "completed", description: "Cl = 2œÄ sin(Œ±) aproximado" },
            { category: "F√≠sica", item: "Efecto stall", status: "completed", description: "P√©rdida de sustentaci√≥n >15¬∞" },
            { category: "F√≠sica", item: "Reynolds number", status: "improvement", description: "Considerar n√∫mero de Reynolds" },
            { category: "F√≠sica", item: "Efectos de Mach", status: "improvement", description: "Compresibilidad en altas velocidades" }
        ];

        // Nuevas Caracter√≠sticas a Probar
        const newFeaturesToTest = [
            { category: "Nuevas Caracter√≠sticas a Probar", item: "Pruebas espec√≠ficas para el sistema de flujo aerodin√°mico con curvas B√©zier", status: "pending", description: "Validar comportamiento de flujos con las nuevas curvas NACA precisas" },
            { category: "Nuevas Caracter√≠sticas a Probar", item: "Validaci√≥n de la f√≠sica de part√≠culas en diferentes condiciones clim√°ticas", status: "pending", description: "Probar part√≠culas en lluvia, nieve y condiciones normales" },
            { category: "Nuevas Caracter√≠sticas a Probar", item: "Pruebas de estabilidad del sistema de sombras 3D y texturas met√°licas", status: "pending", description: "Verificar rendimiento y estabilidad de efectos visuales avanzados" },
            { category: "Nuevas Caracter√≠sticas a Probar", item: "Verificaci√≥n de la correcta separaci√≥n de flujos superior/inferior del ala", status: "pending", description: "Confirmar que los flujos se separan correctamente en la superficie del ala" }
        ];

        // Combine all checklist items
        const allChecklistItems = [...checklistItems, ...newFeaturesToTest];

        let cloudOffset = 0;
        let scaleFactor = 1;

        function getResponsiveTextSize(baseSize) {
            return max(8, baseSize * scaleFactor);
        }

        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;

        function setup() {
            // Detect mobile devices
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

            // Calculate canvas size based on device
            let canvasWidth, canvasHeight;

            if (isMobile) {
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight - 180; // Leave space for controls
                scaleFactor = min(canvasWidth / 800, canvasHeight / 500); // Smaller base for mobile
            } else {
                canvasWidth = min(windowWidth - 300, 1200);
                canvasHeight = min(windowHeight - 100, 700);
                scaleFactor = min(canvasWidth / 1000, canvasHeight / 600);
            }

            createCanvas(canvasWidth, canvasHeight);
            smooth();

            // Initialize controls
            angleSlider = select('#angle-slider');
            showDetails = select('#show-details');
            showPressure = select('#show-pressure');
            showFlows = select('#show-flows');
            showForces = select('#show-forces');

            angleSlider.input(updateAngle);
            updateAngle(); // Initialize

            displayChecklist();

            // Add swipe gesture support for mobile
            if (isMobile) {
                initSwipeGestures();
                initOrientationChange();
            }

            // Initialize lazy loading for any images
            initLazyLoading();
        }

        function initOrientationChange() {
            window.addEventListener('orientationchange', function() {
                // Wait for orientation change to complete
                setTimeout(function() {
                    updateMobileLayout();
                    windowResized();
                }, 500);
            });
        }

        function initLazyLoading() {
            // Basic lazy loading for images (if any are added later)
            const images = document.querySelectorAll('img[data-src]');
            const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const img = entry.target;
                        img.src = img.dataset.src;
                        img.classList.remove('lazy');
                        observer.unobserve(img);
                    }
                });
            });

            images.forEach(img => imageObserver.observe(img));
        }

        function windowResized() {
            // Detect mobile devices
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

            // Recalculate canvas size
            let canvasWidth, canvasHeight;

            if (isMobile) {
                canvasWidth = window.innerWidth;
                canvasHeight = window.innerHeight - 180;
                scaleFactor = min(canvasWidth / 800, canvasHeight / 500);
            } else {
                canvasWidth = min(windowWidth - 300, 1200);
                canvasHeight = min(windowHeight - 100, 700);
                scaleFactor = min(canvasWidth / 1000, canvasHeight / 600);
            }

            resizeCanvas(canvasWidth, canvasHeight);

            // Update mobile layout based on orientation
            updateMobileLayout();
        }

        function updateMobileLayout() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
            const isLandscape = window.innerWidth > window.innerHeight;

            if (isMobile) {
                const controls = document.getElementById('controls');
                const checklist = document.getElementById('checklist');

                if (isLandscape) {
                    // Landscape: controls on left, checklist hidden by default
                    controls.style.bottom = '10px';
                    controls.style.left = '10px';
                    controls.style.right = 'auto';
                    controls.style.maxWidth = 'calc(50vw - 20px)';
                    controls.style.maxHeight = 'calc(100vh - 20px)';

                    checklist.style.left = '-100%';
                    checklist.style.width = '40%';
                    checklist.style.maxWidth = '300px';
                } else {
                    // Portrait: controls at bottom, checklist as overlay
                    controls.style.bottom = '10px';
                    controls.style.left = '10px';
                    controls.style.right = '10px';
                    controls.style.maxWidth = 'none';
                    controls.style.maxHeight = '150px';

                    checklist.style.left = '-100%';
                    checklist.style.width = '80%';
                    checklist.style.maxWidth = '300px';
                }
            }
        }

        function updateAngle() {
            let angleDeg = angleSlider.value();
            select('#angle-value').html(angleDeg);
            angleAttack = radians(angleDeg);
        }

        function resetTest() {
            angleSlider.value(5);
            updateAngle();
            select('#show-details').checked(true);
            select('#show-pressure').checked(true);
            select('#show-flows').checked(true);
            select('#show-forces').checked(true);
        }

        function toggleMobileMenu() {
            const checklist = select('#checklist');
            const overlay = select('#mobile-overlay');
            const breadcrumb = select('#breadcrumb');
            const backBtn = select('#back-button');
            const isOpen = checklist.hasClass('open');

            if (isOpen) {
                closeMobileMenu();
            } else {
                openMobileMenu();
            }
        }

        function openMobileMenu() {
            const checklist = select('#checklist');
            const overlay = select('#mobile-overlay');
            const breadcrumb = select('#breadcrumb');
            const backBtn = select('#back-button');

            checklist.addClass('open');
            overlay.style('display', 'block');
            setTimeout(() => {
                overlay.style('opacity', '1');
            }, 10);

            // Show breadcrumb and back button on mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
            if (isMobile) {
                breadcrumb.style('display', 'block');
                backBtn.style('display', 'block');
            }
        }

        function closeMobileMenu() {
            const checklist = select('#checklist');
            const overlay = select('#mobile-overlay');
            const breadcrumb = select('#breadcrumb');
            const backBtn = select('#back-button');

            checklist.removeClass('open');
            overlay.style('opacity', '0');
            setTimeout(() => {
                overlay.style('display', 'none');
            }, 300);

            // Hide breadcrumb and back button
            breadcrumb.style('display', 'none');
            backBtn.style('display', 'none');
        }

        function goBack() {
            // Simple back navigation - could be enhanced for more complex navigation
            closeMobileMenu();
        }

        function initSwipeGestures() {
            // Add touch event listeners to the document
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
        }

        function handleTouchStart(e) {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }

        function handleTouchMove(e) {
            // Prevent scrolling when swiping horizontally near the edges
            if (Math.abs(e.changedTouches[0].screenX - touchStartX) > 10) {
                e.preventDefault();
            }
        }

        function handleTouchEnd(e) {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipeGesture();
        }

        function filterChecklist(searchTerm) {
            const items = selectAll('.check-item');
            const categories = selectAll('.checklist-category');
            const clearBtn = select('#clear-search');

            if (searchTerm.trim() === '') {
                // Show all items and categories
                items.forEach(item => item.style('display', 'block'));
                categories.forEach(cat => cat.style('display', 'block'));
                clearBtn.style('display', 'none');
                return;
            }

            clearBtn.style('display', 'block');
            searchTerm = searchTerm.toLowerCase();

            items.forEach(item => {
                const text = item.elt.textContent.toLowerCase();
                const matches = text.includes(searchTerm);
                item.style('display', matches ? 'block' : 'none');
            });

            // Show/hide categories based on whether they have visible items
            categories.forEach(cat => {
                const categoryItems = cat.elt.querySelectorAll('.check-item');
                const hasVisibleItems = Array.from(categoryItems).some(item =>
                    item.style.display !== 'none'
                );
                cat.style('display', hasVisibleItems ? 'block' : 'none');

                // Expand category if it has matching items
                if (hasVisibleItems) {
                    const content = cat.elt.querySelector('.category-content');
                    const toggleIcon = cat.elt.querySelector('.toggle-icon');
                    if (content && toggleIcon) {
                        content.style.display = 'block';
                        toggleIcon.textContent = '‚ñº';
                    }
                }
            });
        }

        function quickPreset(preset) {
            switch(preset) {
                case 'all':
                    select('#show-details').checked(true);
                    select('#show-pressure').checked(true);
                    select('#show-flows').checked(true);
                    select('#show-forces').checked(true);
                    break;
                case 'minimal':
                    select('#show-details').checked(false);
                    select('#show-pressure').checked(false);
                    select('#show-flows').checked(true);
                    select('#show-forces').checked(true);
                    break;
                case 'physics':
                    select('#show-details').checked(false);
                    select('#show-pressure').checked(true);
                    select('#show-flows').checked(false);
                    select('#show-forces').checked(true);
                    break;
            }
        }

        function exportChecklist() {
            let content = "# Checklist de Mejoras del Ala - Simulador de Sustentaci√≥n\n\n";
            content += "Generado: " + new Date().toLocaleString() + "\n\n";

            const categories = [...new Set(allChecklistItems.map(item => item.category))];

            categories.forEach(category => {
                content += `## ${category}\n\n`;
                allChecklistItems.filter(item => item.category === category).forEach(item => {
                    const status = item.status === 'completed' ? '‚úÖ' : item.status === 'pending' ? '‚è≥' : 'üí°';
                    content += `- ${status} **${item.item}**: ${item.description}\n`;
                });
                content += "\n";
            });

            // Create download link
            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'checklist_ala.md';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function displayChecklist() {
            const container = select('#checklist-items');
            container.html('');

            const categories = [...new Set(allChecklistItems.map(item => item.category))];

            categories.forEach(category => {
                const categoryId = category.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
                const isExpanded = localStorage.getItem(`checklist-${categoryId}-expanded`) !== 'false'; // Default to expanded

                container.html(container.html() +
                    `<div class="checklist-category">
                        <div class="category-header" onclick="toggleChecklistCategory('${categoryId}')">
                            <h4>${category}</h4>
                            <span class="toggle-icon">${isExpanded ? '‚ñº' : '‚ñ∂'}</span>
                        </div>
                        <div class="category-content" id="category-${categoryId}" style="display: ${isExpanded ? 'block' : 'none'};">`
                );

                allChecklistItems.filter(item => item.category === category).forEach(item => {
                    const statusClass = item.status;
                    const statusText = item.status === 'completed' ? 'Completado' :
                                     item.status === 'pending' ? 'Pendiente' : 'Mejora';
                    const statusColor = item.status === 'completed' ? 'completed' :
                                      item.status === 'pending' ? 'pending' : 'improvement';

                    container.html(container.html() +
                        `<div class="check-item ${statusClass}">
                            <span class="status ${statusColor}">${statusText}</span><br>
                            <strong>${item.item}</strong><br>
                            <small>${item.description}</small>
                        </div>`);
                });

                container.html(container.html() + `</div></div>`);
            });
        }

        function draw() {
            clear();

            // Background gradient
            for (let y = 0; y < height; y++) {
                let inter = map(y, 0, height, 0, 1);
                let c = lerpColor(color(135, 206, 250), color(100, 180, 220), inter);
                stroke(c);
                line(0, y, width, y);
            }

            // Title
            fill(255);
            stroke(0);
            strokeWeight(max(1, 2 * scaleFactor));
            textSize(max(12, 20 * scaleFactor));
            textAlign(CENTER);
            text('Test del Ala - Checklist de Mejoras', width / 2, 35 * scaleFactor);

            // Draw airfoil
            push();
            translate(width / 2, height / 2);
            scale(1.2 * scaleFactor);
            rotate(angleAttack * 0.3);

            // Main airfoil profile
            fill(40, 40, 50);
            stroke(20, 20, 30);
            strokeWeight(3);

            beginShape();
            let leX = -150, leY = 0;
            vertex(leX, leY);
            bezierVertex(-100, -20, -50, -40, 0, -50);
            bezierVertex(50, -50, 100, -40, 150, -20);
            vertex(170, 0);
            bezierVertex(150, 10, 100, 20, 50, 25);
            bezierVertex(0, 25, -50, 20, -100, 10);
            bezierVertex(-125, 5, leX, leY);
            endShape(CLOSE);

            // Leading edge reinforcement
            fill(20, 20, 30);
            noStroke();
            ellipse(leX, leY, 12, 10);

            // Flaps for high angles
            if (degrees(angleAttack) > 15) {
                fill(100, 149, 237, 200);
                stroke(80, 129, 217);
                strokeWeight(2);
                beginShape();
                vertex(100, -45); vertex(140, -40); vertex(145, -30); vertex(105, -35);
                endShape(CLOSE);
                beginShape();
                vertex(100, 20); vertex(140, 15); vertex(145, 25); vertex(105, 30);
                endShape(CLOSE);
            }

            // Navigation light
            fill(0, 255, 0);
            stroke(0, 150, 0);
            strokeWeight(1);
            ellipse(165, -5, 8, 8);

            pop();

            // Flow visualization
            if (showFlows.checked()) {
                flowOffset += 0.02;

                // Upper flow (blue)
                stroke(135, 206, 235, 160);
                strokeWeight(2);
                noFill();
                for (let i = 0; i < 8; i++) {
                    let baseY = height / 2 - 35 - i * 4;
                    let xOffset = (flowOffset * 3 + i * 15) % (width + 200) - 100;
                    let curve = degrees(angleAttack) * 1.5;

                    beginShape();
                    vertex(xOffset, baseY);
                    bezierVertex(xOffset + 50, baseY - 10 - curve, xOffset + 120, baseY - 18 - curve, xOffset + 200, baseY - 5 - curve);
                    endShape();
                }

                // Lower flow (orange)
                stroke(255, 140, 100, 160);
                for (let i = 0; i < 8; i++) {
                    let baseY = height / 2 + 35 + i * 4;
                    let xOffset = (flowOffset * 1.5 + i * 15) % (width + 200) - 100;
                    let curve = degrees(angleAttack) * 1.2;

                    beginShape();
                    vertex(xOffset, baseY);
                    bezierVertex(xOffset + 50, baseY + 10 + curve, xOffset + 120, baseY + 18 + curve, xOffset + 200, baseY + 5 + curve);
                    endShape();
                }
            }

            // Pressure visualization
            if (showPressure.checked()) {
                push();
                translate(width / 2, height / 2);
                scale(1.2);

                // High pressure below (red)
                for (let layer = 0; layer < 3; layer++) {
                    fill(255, 100, 100, 20 - layer * 5);
                    noStroke();
                    beginShape();
                    for (let x = -120; x <= 120; x += 5) {
                        let yb = -0.12 * sin(PI * x / 240) * 50;
                        vertex(x, yb + 2 + layer);
                    }
                    vertex(120, 30 + layer);
                    vertex(-120, 30 + layer);
                    endShape(CLOSE);
                }

                // Low pressure above (blue)
                for (let layer = 0; layer < 3; layer++) {
                    fill(100, 150, 255, 15 - layer * 3);
                    noStroke();
                    beginShape();
                    for (let x = -120; x <= 120; x += 5) {
                        let yt = 0.12 * sin(PI * x / 240) * 50;
                        vertex(x, yt - 2 - layer);
                    }
                    vertex(120, -30 - layer);
                    vertex(-120, -30 - layer);
                    endShape(CLOSE);
                }

                pop();
            }

            // Forces
            if (showForces.checked()) {
                let leX = width / 2 - 180;
                let leY = height / 2;

                // Calculate lift magnitude based on angle of attack (simplified)
                let liftMagnitude = max(35, degrees(angleAttack) * 3.5 + 35);
                let weightMagnitude = 45; // Constant weight

                // Lift force (green) - upward arrow from center of wing
                let liftEndY = leY - liftMagnitude;
                drawArrow(leX, leY, leX, liftEndY, color(0, 255, 0), 5, 1.3);

                // Lift label with better visibility
                fill(0);
                stroke(255);
                strokeWeight(2);
                textSize(getResponsiveTextSize(13));
                textAlign(LEFT);
                text('Sustentaci√≥n', leX + 18, leY - liftMagnitude/2);

                fill(0, 255, 0);
                noStroke();
                textSize(getResponsiveTextSize(13));
                text('Sustentaci√≥n', leX + 18, leY - liftMagnitude/2);

                // Add lift value
                fill(0);
                stroke(255, 255, 255, 200);
                strokeWeight(1);
                textSize(getResponsiveTextSize(11));
                text((liftMagnitude * 0.08).toFixed(1) + ' N', leX + 18, leY - liftMagnitude/2 + 18);

                fill(0, 200, 0);
                noStroke();
                textSize(getResponsiveTextSize(11));
                text((liftMagnitude * 0.08).toFixed(1) + ' N', leX + 18, leY - liftMagnitude/2 + 18);

                // Weight force (red) - downward arrow from center
                let weightEndY = leY + weightMagnitude;
                drawArrow(leX, leY, leX, weightEndY, color(255, 0, 0), 5, 1.1);

                // Weight label with high contrast for better visibility
                fill(0);
                stroke(255);
                strokeWeight(3);
                textSize(getResponsiveTextSize(14));
                textAlign(LEFT);
                text('Peso', leX + 18, leY + weightMagnitude/2);

                fill(255, 0, 0);
                stroke(255, 255, 255, 150);
                strokeWeight(1);
                textSize(getResponsiveTextSize(14));
                text('Peso', leX + 18, leY + weightMagnitude/2);

                // Add weight value
                fill(0);
                stroke(255, 255, 255, 200);
                strokeWeight(1);
                textSize(getResponsiveTextSize(11));
                text((weightMagnitude * 0.08).toFixed(1) + ' N', leX + 18, leY + weightMagnitude/2 + 18);

                fill(200, 0, 0);
                noStroke();
                textSize(getResponsiveTextSize(11));
                text((weightMagnitude * 0.08).toFixed(1) + ' N', leX + 18, leY + weightMagnitude/2 + 18);

                // Drag force (orange) - horizontal arrow to the left
                let dragMagnitude = degrees(angleAttack) * 0.6 + 8; // Drag increases with angle
                let dragEndX = leX - dragMagnitude;
                drawArrow(leX, leY, dragEndX, leY, color(255, 140, 0), 4, 0.9);

                // Drag label
                fill(0);
                stroke(255);
                strokeWeight(2);
                textSize(getResponsiveTextSize(12));
                textAlign(CENTER);
                text('Resistencia', leX - dragMagnitude/2, leY - 10);

                fill(255, 140, 0);
                noStroke();
                textSize(getResponsiveTextSize(12));
                text('Resistencia', leX - dragMagnitude/2, leY - 10);

                // Add drag value
                fill(0);
                stroke(255, 255, 255, 200);
                strokeWeight(1);
                textSize(getResponsiveTextSize(10));
                text((dragMagnitude * 0.03).toFixed(2) + ' N', leX - dragMagnitude/2, leY + 8);

                fill(200, 100, 0);
                noStroke();
                textSize(getResponsiveTextSize(10));
                text((dragMagnitude * 0.03).toFixed(2) + ' N', leX - dragMagnitude/2, leY + 8);

                // Draw force balance indicator
                if (abs(liftMagnitude - weightMagnitude) < 15) {
                    fill(255, 255, 0, 180);
                    stroke(0);
                    strokeWeight(max(1, 2 * scaleFactor));
                    ellipse(leX, leY, 12 * scaleFactor, 12 * scaleFactor);
                    fill(0);
                    noStroke();
                    textSize(getResponsiveTextSize(10));
                    textAlign(CENTER);
                    text('‚â°', leX, leY + 3 * scaleFactor);
                }
            }

            // Labels
            if (showDetails.checked()) {
                fill(255);
                stroke(0);
                strokeWeight(1);
                textSize(10);
                textAlign(CENTER);
                text('NACA 2412', width / 2, height / 2 + 50);

                fill(135, 206, 235);
                textSize(12);
                textAlign(LEFT);
                text('Aire R√°pido (Baja Presi√≥n)', 50, height / 2 - 50);

                fill(255, 140, 100);
                text('Aire Lento (Alta Presi√≥n)', 50, height / 2 + 70);
            }
        }

        function drawArrow(x1, y1, x2, y2, arrowColor, weight = 4, scaleFactor = 1) {
            // Calculate arrow length and direction
            let dx = x2 - x1;
            let dy = y2 - y1;
            let length = sqrt(dx * dx + dy * dy);
            let angle = atan2(dy, dx);

            // Scale arrow based on length
            let arrowLength = max(25, length * 0.4) * scaleFactor;
            let arrowWidth = weight * 2.5 * scaleFactor;

            push();
            translate(x1, y1);
            rotate(angle);

            // Draw arrow shadow for depth
            stroke(0, 0, 0, 50);
            strokeWeight(weight + 2);
            line(2, 2, length - arrowLength + 2, 2);

            // Draw arrow shaft with gradient effect
            for (let i = 0; i < length - arrowLength; i += 3) {
                let alpha = map(i, 0, length - arrowLength, 255, 150);
                stroke(red(arrowColor), green(arrowColor), blue(arrowColor), alpha);
                strokeWeight(weight);
                line(i, 0, i + 3, 0);
            }

            // Draw arrowhead with better shape and shadow
            translate(length - arrowLength, 0);

            // Arrowhead shadow
            fill(0, 0, 0, 50);
            noStroke();
            triangle(2, 2, -arrowLength + 2, -arrowWidth/2 + 2, -arrowLength + 2, arrowWidth/2 + 2);

            // Main arrowhead
            fill(arrowColor);
            noStroke();
            triangle(0, 0, -arrowLength, -arrowWidth/2, -arrowLength, arrowWidth/2);

            // Add arrowhead base for better appearance
            rect(-arrowLength, -arrowWidth/4, arrowLength * 0.3, arrowWidth/2);

            pop();
        }
    </script>
</body>
</html>
